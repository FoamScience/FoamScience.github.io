[{"section":"Blog","slug":"/blog/object-registration-in-openfoam/","title":"Object Registration in OpenFOAM","description":"How to get a (const) reference for an OpenFOAM variable from &#39;everywhere&#39;","date":"September 12, 2018","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/objectregistry-openfoam_hucef0e6d38159ea556f03a19952d0fda5_72961_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"241\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/objectregistry-openfoam_hucef0e6d38159ea556f03a19952d0fda5_72961_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/objectregistry-openfoam_hucef0e6d38159ea556f03a19952d0fda5_72961_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/objectregistry-openfoam_hucef0e6d38159ea556f03a19952d0fda5_72961_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"programming","tags":"OpenFOAM, Vim","content":"Being aware of all the important variables during the simulation is a nice feature to have in any CFD software. I\u0026rsquo;ve even seen some software developers \u0026ldquo;brag\u0026rdquo; about how many \u0026ldquo;variables\u0026rdquo; their simulators efficiently manage at run time. Today, we\u0026rsquo;ll discover how OpenFOAM solvers keep track of model data used across libraries.\nKnow the difference between Object Registration and Run-Time Selection Table Note\nWhen I mention \u0026lsquo;Object registration,\u0026rsquo; I am not referring to \u0026lsquo;Model registration,\u0026rsquo; which pertains to the mechanism enabling the reporting of potential models in case the user input is unexpected (e.g., when utilizing a non-existent Boundary Condition Type). Instead, I am referring to the mechanism that enables the program to retrieve references to various \u0026lsquo;data\u0026rsquo; objects (such as volScalarFields, etc.) under the solver\u0026rsquo;s direct or indirect control. Please read this section to better understand the distinction.\nTraditional C++ programming will likely employ a \u0026ldquo;Factory-like\u0026rdquo; design to create new objects: A virtual base class will have a static create() (or a static New() in the case of OpenFOAM classes) to generate a pointer (of some kind) to the newly created model.\nThis traditional technique is used when the programmer wants to provide users the ability to \u0026ldquo;select\u0026rdquo; a model from a set of pre-defined ones (child classes of the base class).\nIn OpenFOAM, it is common to equip the virtual base class (usually belonging to the Foam namespace) with a static New() method that returns an autoPtr pointing to the newly created instance of the model class (autoPtr is used so that the created object cannot be referred to by more than one pointer). Of course, \u0026ldquo;templates\u0026rdquo; may complicate things a bit more, but nothing we can\u0026rsquo;t live with.\nThis New() method would typically read the model\u0026rsquo;s name from a dictionary, check if such a model is \u0026ldquo;registered\u0026rdquo; to the RunTime selection Table, then construct an object of the appropriate type. This process is referred to as the \u0026ldquo;selection of a model.\u0026rdquo;\nOlder C++ code might contain overloaded versions of New() (each returning a different type), but OpenFOAM uses templates and a collection of macros to construct a RunTimeSelectionTable that New uses to check for existence and select the model.\nHowever, that\u0026rsquo;s not the primary focus of this post. Instead, let\u0026rsquo;s delve into the registration of model data. For example, consider a scenario where a library attempts to access a field created and managed by another library. To illustrate, suppose we have a library called transportModels.so, and its basic transportModel class includes a member, volScalarField rho. Now, let\u0026rsquo;s say we\u0026rsquo;re working on another library and we need a (possibly const) reference to this field without statically linking to transportModels.so—which would result in a cyclic dependency between the two libraries. How can one obtain a reference to such a field?\nThis is precisely the situation where object registration becomes necessary.\nOpenFOAM objectRegistry and regIOobject OpenFOAM solvers maintain a \u0026ldquo;hierarchical database,\u0026rdquo; logging objects at various levels:\nThe primary registry is always the Time object (runTime). The second tier in the database logs mesh regions and the global controlDict. At lower levels, \u0026ldquo;sub-objects\u0026rdquo; are registered (e.g., each mesh region having its own fvSchemes, fvSolution, mesh data, the fields associated with the mesh region created in createFields.H\u0026hellip; etc). Note that each object in the database \u0026ldquo;can be\u0026rdquo; a database of registered objects, enabling the hierarchical structure. When referring to \u0026ldquo;mesh regions,\u0026rdquo; I\u0026rsquo;m indicating different mesh objects (for instance, a mesh for fluids and another for solid regions in fluid-solid interaction simulations).\nTip\nIf two \u0026ldquo;Time instances\u0026rdquo; are used in a solver, we would have two independent databases, and it makes complete sense!\nFor illustration, standard solvers databases would look like this:\n* runTime # objectRegistry |--\u0026gt; controlDict # regIOobject (can\u0026#39;t have sub-entries attached to it) |--\u0026gt; mesh1 # objectRegistry (a database) |--\u0026gt; points, owner, neighbour, cellZones ... |--\u0026gt; fvSchemes, fvSolution |--\u0026gt; U, p |--\u0026gt; mesh2 |--\u0026gt; points, owner, neighbour, cellZones ... |--\u0026gt; fvSchemes, fvSolution |--\u0026gt; U, p Tip\nThis Hierarchy is kept in memory, but the same class handles how it\u0026rsquo;s written to disk.\nThe database class is called objectRegistry (so it\u0026rsquo;s a database and an entry in a database at the same time), and in order for objects to auto-register to a database, they must inherit from regIOobject class.\nThe inheritance from regIOobject promotes the object into an auto-registered object and it requires to implement the pure virtual member function writeData() (not write()) so that when the database issues the order of writing to disk to all its child entries, the child will be able to write itself properly :\nvirtual bool writeData(Ostream\u0026amp;) const; An example of a simple, non-standard class which inherits from regIOobject is the basic well class in my Reservoir Simulation toolkit . A well can then be written to disk as a regular dictionary.\nCross library interaction in OpenFOAM Now that we all have a good understanding of the hierarchical registration in OpenFOAM, let\u0026rsquo;s dive into how to use such mechanism for our benefit.\nIn practice, when writing OpenFOAM libraries, it\u0026rsquo;s common to pass a mesh reference to the base model\u0026rsquo;s constructor (You can do very little without a reference to the mesh, really). Thus, the mesh is the number-one database to log our objects to: Which database to use is decided at the object\u0026rsquo;s construction time (by calling regIOobject\u0026rsquo;s constructor with the right third parameter).\nIn standard solvers, the mesh is created by passing an IOobject to the constructor of the parent class polyMesh which passes it to objectRegistry\u0026rsquo;s constructor:\n// fvMesh is an objectRegistry Foam::fvMesh mesh ( Foam::IOobject ( Foam::fvMesh::defaultRegion, runTime.timeName(), runTime, // That\u0026#39;s the database we branch into Foam::IOobject::MUST_READ ) ); Tip\nAnd you can verify that the Time class is not registered to anything.\nNow, say we registered a volScalarField with the name of \u0026ldquo;fName\u0026rdquo; to the previous mesh object (See createFields.H file of any standard solver for examples). How can we refer to it in a Boundary Condition Type we\u0026rsquo;re adding?\nWell, that\u0026rsquo;s easy, we just use fvMesh\u0026rsquo;s interface:\n// Const-ref to the field named fName const volScalarField\u0026amp; fN = mesh.lookupObject(\u0026#34;fName\u0026#34;); // Ref to the field named fName volScalarField\u0026amp; fN = mesh.lookupObjectRef(\u0026#34;fName\u0026#34;); Well, for a more sophisticated way, we may give the user the option of selecting the field\u0026rsquo;s name:\n// Read the name if provided word theName = someDict.lookupOrDefault\u0026lt;word\u0026gt;(\u0026#34;fieldName\u0026#34;,\u0026#34;fName\u0026#34;); // Const-ref to the field named fName const volScalarField\u0026amp; fN = mesh.lookupObject(theName); This particular trick may complicate things for beginners with all the \u0026ldquo;didn\u0026rsquo;t find a field in the database\u0026rdquo; Fatal Errors, but it\u0026rsquo;s a decent way to program things in OpenFOAM. Anyway, I hope this article clarified at least what the third argument to IOobject\u0026rsquo;s constructor is meant to do :smile:\nIf you have any suggestions or comments on this matter, don\u0026rsquo;t hesitate, fire at me bellow.\n"},{"section":"Blog","slug":"/blog/the-forall-macro-in-openfoam/","title":"The forAll Macro in OpenFOAM","description":"Guys, forAll is just a User-defined shorthand for standard CPP &#39;for&#39;, OK!","date":"August 29, 2018","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/forAll-openfoam-cpp_hu9adf402e5ea58479103080fa88241038_52836_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"244\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/forAll-openfoam-cpp_hu9adf402e5ea58479103080fa88241038_52836_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/forAll-openfoam-cpp_hu9adf402e5ea58479103080fa88241038_52836_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/forAll-openfoam-cpp_hu9adf402e5ea58479103080fa88241038_52836_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"programming","tags":"OpenFOAM, C++","content":"Because of the frequent use of range-like loops in OpenFOAM (in the official code base, forks, and any independent work, for that matter), the developers have provided a \u0026ldquo;shortcut\u0026rdquo; to loop through all elements of a list—any list. This post aims to address the common misuse of this shortcut. Believe it or not, people abuse the forAll macro in every possible way.\nThe forAll macro and its “friends” First of all, we all know that forAll is not part of C++, so it is a user-defined macro. Assuming a recent fork/version of OpenFOAM is sourced, the definition of this macro and similar ones can be found by running the following shell commands:\ncd $FOAM_SRC/$WM_PROJECT grep -r . -e \u0026#34;define.*forAll\u0026#34; The previous command reveals that there are at least four (4, foam-extend has some more) defined macros to loop through \u0026ldquo;collections\u0026rdquo;:\nThe good old forAll and its reversed-looping version forAllReverse. A forAllIter macro specialized in iterating over a Container using an \u0026ldquo;iterator\u0026rdquo; and a const-version of it. Yep, browsing source code is extremely useful (These macros are defined in UList.H).\nPeople need to understand that forAll(list, i) is \u0026ldquo;just\u0026rdquo; a shortcut to for (int i=0; i\u0026lt;(list).size(); i++). Although i is actually a Foam::label in standard OF versions. Strictly speaking; the macro just \u0026ldquo;works\u0026rdquo; on any container that has a size() member method (Think of it as a vector of a known size - at construction time). Such containers will probably (publicly) inherit from the UList (The most lightweight-efficient base class for vector-like lists of elements with contiguous storage).\nLet\u0026rsquo;s examine a very simple example of constructing a scalarList (a List\u0026lt;scalar\u0026gt;, publicly inheriting from UList\u0026lt;scalar\u0026gt;).\n#include \u0026#34;fvCFD.H\u0026#34; // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * // int main(int argc, char *argv[]) { // Create a list of some scalars scalarList someScalars(10, 0); // Perfectly fine use of forAll forAll(someScalars, sc) { someScalars[sc] = doSomeCalculations(sc); }; Info\u0026lt;\u0026lt; \u0026#34;End\\n\u0026#34; \u0026lt;\u0026lt; endl; return 0; } But this may be misleading; what if someone uses the macro to loop over a “different” type of container, say a dictionary? Is forAll suitable for such tasks?\nThe answer is in the previous example, actually: Common use of forAll requires the list object to\nHave a size() member method. Be efficiently indexable with some method/operator (operator[] in this case). Otherwise, there is no benefit in looping through some collection if you can\u0026rsquo;t access its elements!! So, if dictionary objects verify these requirements; we\u0026rsquo;re golden.\nIn fact, the DictionaryBase Template class publicly inherits from the [Link] List Type it is templated on. It\u0026rsquo;s easy to follow the inheritance diagram of the most commonly used class dictionary to see that there is no size() method defined anywhere. Also, how would one refer to an entry as dictionary[i]??\nIt should be obvious now that forAll is not the right macro to use in this case. That\u0026rsquo;s where the second family of macros kicks in: Instead of using a (possibly more efficient) predefined-size container, some situations require the use of “more dynamic” ones that only hold “pointers” to their begin/end positions. An iterator is then used to go back and forth between these positions.\nA nice usage of this macro can be found at line 175 of solution.C file so newer versions of OpenFOAM would understand the older specification of fvSolution.solver.\nThe const-iter version of forAllIter is also used to read entries of a dictionary into a HashTable… you can find an example at line 146 of HashPtrTableIO.C .\nA word on UList in OpenFOAM As far as I can tell, this class is just “well written” - “well thought through”. Its purpose is to provide an efficient base class for “Sub-Lists”. A quick look on the list of classes that directly inherit from it shows how important UList is.\nBy the way, the class also holds a random access iterator; so it can be used with forAllIter: We use an object (usually called iter) to “point” to a list item each time we iterate. The list item itself is accessed by dereferencing the pointer (*iter).\nI\u0026rsquo;m not aware of a way to get the “index” of an element in a List; It would be inefficient! So I never bothered to search for one. Another thing I should point out is that std::distance probably won\u0026rsquo;t work without some serious Type Casting :). It\u0026rsquo;s (was?) dangerous anyway, and I don\u0026rsquo;t know if a similar function is available for OpenFOAM iterators).\nIn fact, the use of std::distance takes away one the most important features of iterator-based loops: The ability to loop through a container where either .begin() or .end() is not reachable from the other (possibly by incrementing iter) as it results in “undefined behavior”.\nNote\nIn recent OpenFOAM versions, GeometricField (volScalarFields …) inherits from UList, so, one can typically loop through their elements with both macros; although template specializations specialize the sense of “loop through their elements”: Some types support looping through internalField; others make it so the loop hits everything.\nA word on dictionary in OpenFOAM This class a good example of a lot of things. “An iterator-based container” as I introduced it in this post is just the tip of the iceberg. The reason I chose it for this post is that most OpenFOAM users consider a dictionary to be a “list” which is not entirely true. The similarity of, for example, getting some IDs (0, 1, 2, 3 … ) for mesh patches from the boundary files does not mean a dictionary is indexable (I\u0026rsquo;m talking about “old-fashion” indexing here).\n"},{"section":"Blog","slug":"/blog/vim-openfoam-power-part2/","title":"Customize VIM to work efficiently with OpenFOAM - Part 2","description":"Working with OpenFOAM case files gets really tedious if the text editor is not selected properly; and with VIM I still feel like missing some features, that&#39;s why customizing VIM for such tasks is the best path to take","date":"August 28, 2018","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/vim-openfoam_hu2ee0a4cb629d438b90e279549678bc92_82586_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"250\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/vim-openfoam_hu2ee0a4cb629d438b90e279549678bc92_82586_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/vim-openfoam_hu2ee0a4cb629d438b90e279549678bc92_82586_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/vim-openfoam_hu2ee0a4cb629d438b90e279549678bc92_82586_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"productivity","tags":"OpenFOAM, Vim","content":"We\u0026rsquo;ve seen in the previous part some ways to improve our interaction with OpenFOAM case directories and files. In this new post, we want to implement something that facilitates running blockMesh, or the case solver, right from inside VIM; without going back to the shell. Of course, our implementation should catch errors in the quick fix list (if there are any), then go to the concerned file, and put the cursor on the error line.\nWarning\nThis post is outdated; there are better ways to efficiently edit OpenFOAM files with (Neo)Vim:\ntree-sitter-foam : OpenFOAM syntax highlighting using tree-sitter for NeoVim. foam-language-server : A language server for OpenFOAM files. For this, we\u0026rsquo;ll use two main VIM facilities: VIM compilers and QuickFix list.\nThe compilers are used to automatically run a shell command on a file. For example:\nRunning a gcc (or make if there is a makeFile) command on a *.cpp file would compile it to an executable. Running a pdflatex (or better latexmk) command on a Latex file would compile a PDF version of the document. Running a blockMesh command on a blockMeshDict would build the mesh and check for errors in blockMesh\u0026rsquo;s output. In fact, we can run as many commands as we want on the file using VIM compilers. Think: Generate the mesh, check its validity, set fields, and run appropriate solvers. (In my opinion, this kind of workflow beats GUIs to death.)\nSo, let\u0026rsquo;s get to work. We need to know how VIM\u0026rsquo;s default compiler plugins are set, and the best way to learn is by looking at examples. On Unix systems, the default compilers should be in /usr/share/vim/vim74/compiler directory. You can use VIM\u0026rsquo;s ex-command :compile to find out where they are on your system.\nStudying an example VIM compiler First of all, a VIM compiler plugin is nothing more than a short VimL script, configuring two main things: errorformat (scanf-style strings, separated by commas, showing the format of error lines) and makeprg (make program, the shell executable to run).\nAs an example, let\u0026rsquo;s go through the ant-compiler line by line:\n\u0026#34; Vim Compiler File \u0026#34; Compiler:\tant \u0026#34; Maintainer:\tJohannes Zellner \u0026lt;johannes@zellner.org\u0026gt; \u0026#34; Last Change:\tMi, 13 Apr 2005 22:50:07 CEST The header, just for information, then we have some checks to perform:\nif exists(\u0026#34;current_compiler\u0026#34;) finish endif let current_compiler = \u0026#34;ant\u0026#34; if exists(\u0026#34;:CompilerSet\u0026#34;) != 2\t\u0026#34; older Vim always used :setlocal command -nargs=* CompilerSet setlocal \u0026lt;args\u0026gt; endif The first \u0026ldquo;if\u0026rdquo; structure checks if the compiler is already set; if it\u0026rsquo;s the case, Vim will leave the script. If not, it declares current_compiler as \u0026ldquo;ant\u0026rdquo; (so the next time the script executes, it will be finished in the first \u0026ldquo;if\u0026rdquo; structure). The second \u0026ldquo;if\u0026rdquo; statement sets compatibility stuff for older Vim versions.\nAll the cpo-related stuff is set to configure Vi-compatibility options; we don\u0026rsquo;t need to learn about this topic, just don\u0026rsquo;t touch those lines!\nThe line CompilerSet makeprg=ant sets the Ant program as the make program. When you execute the Ex-command :make, Vim runs ant in a shell and watches for its output.\nCompilerSet errorformat=\\ %#[%.%#]\\ %#%f:%l:%v:%*\\\\d:%*\\\\d:\\%t%[%^:]%#:%m shows Vim how to find the error line and what to extract from it (explained in more detail in the next section).\nlet s:cpo_save = \u0026amp;cpo set cpo\u0026amp;vim CompilerSet makeprg=ant \u0026#34; first line: \u0026#34; ant with jikes +E, which assumes the following \u0026#34; two property lines in your \u0026#39;build.xml\u0026#39;: \u0026#34; \u0026#34; \u0026lt;property name = \u0026#34;build.compiler\u0026#34; value = \u0026#34;jikes\u0026#34;/\u0026gt; \u0026#34; \u0026lt;property name = \u0026#34;build.compiler.emacs\u0026#34; value = \u0026#34;true\u0026#34;/\u0026gt; \u0026#34; \u0026#34; second line: \u0026#34; ant with javac \u0026#34; \u0026#34; note that this will work also for tasks like [wtkbuild] \u0026#34; CompilerSet errorformat=\\ %#[%.%#]\\ %#%f:%l:%v:%*\\\\d:%*\\\\d:\\ %t%[%^:]%#:%m, \\%A\\ %#[%.%#]\\ %f:%l:\\ %m,%-Z\\ %#[%.%#]\\ %p^,%C\\ %#[%.%#]\\ %#%m \u0026#34; ,%-C%.%# let \u0026amp;cpo = s:cpo_save unlet s:cpo_save Using errorformats to catch OpenFOAM Fatal Errors These errorformats are similar to regular expressions. Assume a program outputting errors in the following format:\nError: something-is-wrong in /path/to/file at line 25\nTo match this error line, we use a single scanf-style string, that may contain special items (these are the most important ones):\n%f matches a file name (a string), eg. /path/to/file %l matches a line number (digits), eg. 25 %m matches an error message, eg. something-is-wrong %*{conv} converts stuff from regexp to scanf string, eg. %*[a-z] matches any number of lowercase alphabets. Thus, the example line would be matched with \\Error: %m in %f at line %l\nBuilding a compiler plugin for blockMesh The goal of this section is to build a blockMesh-compiler for VIM which can be used to browse errors when the tool fails. For this, we need to create our custom-compilers directory $HOME/.vim/compiler.\nCopy the ant.vim compiler to that directory and rename it as blockMesh.vim, on Unix systems, one can say:\ncp /usr/share/vim/vim74/compiler/ant.vim ~/.vim/compiler/blockMesh.vim Modify the header so it suits your preferences, and then start building the custom VIM compiler:\nHopefully, you are editing the file with VIM. Change all occurrences of \u0026ldquo;ant\u0026rdquo; to \u0026ldquo;blockMesh\u0026rdquo; in the file :%s/ant/blockMesh/g Time to set the \u0026ldquo;errorformat\u0026rdquo;: We know that OpenFOAM displays errors in multiple lines (if you write \u0026ldquo;hxe\u0026rdquo; instead of \u0026ldquo;hex\u0026rdquo; in a blockMeshDict): --\u0026gt; FOAM FATAL IO ERROR: CellShape has unknown model on line 45 the word \u0026#39;hxe\u0026#39; file: /home/elwardi/OpenFOAM/elwardi-4.1/run/movingCone/system/blockMeshDict.blocks at line 45. Note that this is NOT a general FOAM ERROR; some other IO errors specify a range of lines; others suggest solutions before stating the error-line.\nThe most important line is probably the one stating the filename, and the exact line to jump to (these will be stored in %f and %l respectively).However, there are some problems in the filename: notice the ending .blocks appended to it, in fact, things could be messier: .ddtschemes.default.\nHow many dots are there in the filename? The real problem is that the path/to/case always contains a dot character (frrom the OpenFOAM version, eg. user-4.1), so matching from the start of the path to the first dot character won\u0026rsquo;t work!\nInstead, we do notice that versions are expressed in digits, and that case names usually contain no dots (hopefully); so, matching the path up to the first dot character preceding an alphabet character is a good idea: CompilerSet errorformat=\\file:\\ %f\\.%[a-z]%*[a-z\\ ]\\ line\\ %l\\.\n%f matches the string \u0026ldquo;file: \u0026quot; at the start of line, then starts storing the filename up to the first dot that falls immediately before a lowercase alphabet character (hopefully, that\u0026rsquo;s the keyword .blocks, or .fvSchemes \u0026hellip;). Then we\u0026rsquo;ll have some lowercase characters and spaces until we reach the last line before \u0026ldquo;line\u0026rdquo; string, then %l catches the line number (in case there are two, it catches the last one!). Now, what to tell the user? Well, It\u0026rsquo;s good to have a message at the status line saying \u0026ldquo;CellShape has unknown model \u0026hellip;\u0026rdquo;, so, we should use a complex multi-line errorformat! But, still we\u0026rsquo;ll have to deal with the problem of how many lines are there between the line that tells our message and the line that spells out the error line.\nThis is actually troublesome, so, I\u0026rsquo;ve decided to approach the situation differently: We leave our filename and error-line alone, and add another error that captures only the message (using a simple multi-line error-format).\nCompilerSet errorformat=\\file:\\ %f\\.%[a-z]%*[a-z\\ ]\\ line\\ %l\\. \\%E--\u0026gt;\\ %*[A-Z:\\ ],%Z%m %E denotes the start of a multi-line error. Then we find the line saying Fatal IO Error (starts with –\u0026gt; then there are some uppercase letters,semicolons, and spaces). %Z denotes the end of multi-line error (which is only one line here!) then we capture everything in the second line as a %m (an error message). The compiler plugin is now complete:\n\u0026#34; Vim Compiler File \u0026#34; Compiler: blockMesh \u0026#34; Fadeli Mohammed Elwardi \u0026lt;foamscience.github.io\u0026gt; if exists(\u0026#34;current_compiler\u0026#34;) finish endif let current_compiler = \u0026#34;blockMesh\u0026#34; if exists(\u0026#34;:CompilerSet\u0026#34;) != 2 \u0026#34; older Vim always used :setlocal command -nargs=* CompilerSet setlocal \u0026lt;args\u0026gt; endif let s:cpo_save = \u0026amp;cpo set cpo\u0026amp;vim CompilerSet makeprg=blockMesh CompilerSet errorformat= \\\\file:\\ %f\\.%[a-z]%*[a-z\\ ]\\ line\\ %l\\., \\%E-\u0026gt;\\ %*[A-Z:\\ ],%Z%m let \u0026amp;cpo = s:cpo_save unlet s:cpo_save And you should be ready to test it with a sample (erroneous) blockMeshDict:\nMake something of importance go wrong in a blockMeshDict (the last ; in a block is not that important). While editing blockMeshDict, run :compile blockMesh to set the correct compiler (We\u0026rsquo;ll improve on this). Hopefully your working directory is set by our previous customFoam script, if it is the case, run the ex-command :make and check that beautiful (and useful) error message! To automatically jump to the error line, type :cn (short of cnext). {{ notice \u0026ldquo;tip\u0026rdquo; }} The error format can\u0026rsquo;t handle \u0026ldquo;from line 15 to line 18.\u0026rdquo; lines, because no file path will be output in such lines! {{ /notice }}\nNow that VIM knows how to handle blockMesh, let\u0026rsquo;s introduce it to the other FOAM applications (we\u0026rsquo;ll be doing just solvers for illustration). Wait, should we repeat the work done previously tens of times? Absolutely not.\nThe goal of this blog post is to achieve this work-flow:\nWhen I read in a FOAM File, VIM changes its working dir. to case dir. (already implemented in customFoam.vim, see this earlier post ) VIM looks for the suitable OpenFOAM solver for the current case (mentioned in controlDict). VIM sets the right solver as the makeprg automatically. When I run :make (Or press a shortcut to it), VIM will filter the output to show me the errors if there are any. One more thing, I want my own solvers to be involved, so, I won\u0026rsquo;t generate a list of standard solvers and compare anything to its content. That\u0026rsquo;s one lousy approach to take!\nInstead, I\u0026rsquo;m going to define two functions: The first one, in customFoam.vim, which searches and stores the solver name, and the second sets the option makeprg dynamically in a general compiler plugin called foam.vim.\nUse FOAMGetApplication to get solver name From any file in the case dir., we can tell VIM what solver is to be used with the current case because it\u0026rsquo;s mentioned in the controlDict file. Actually, we have two options here:\nUse VIM to take a look at controlDict, and store a string representing the solver name. Or, do it the FOAM way (use run functions: getApplication), which needs a working Installation of OpenFOAM (but that\u0026rsquo;s Ok, you won\u0026rsquo;t be reading this guide otherwise). This method is heavily used in .Allrun shell scripts. In order to learn how VIM interacts with the system, we\u0026rsquo;ll use the second option: We\u0026rsquo;ll add a FOAMGetApplication() function to our customFoam.vim\nfunction! FOAMGetApplication() \u0026#34; Source run functions and execute getApplication let cmd=\u0026#34;. $WM_PROJECT_DIR/bin/tools/RunFunctions \u0026amp;\u0026amp; getApplication\u0026#34; let foamApp=system(cmd)[:-2] echomsg \u0026#39;This case is set to be simulated with: \u0026#39;.foamApp return foamApp endfunction cmd is a string, representing the shell command that sources run functions and then executes getApplication in the current case dir. foamApp is the output of the previous command (solver name), the [:-2] part deletes the last two characters from the output of the command (by default, It will output icoFoam @, the last two characters are not needed). echomsg writes messages to the status line, and keeps them in messages list (run :messages). The general VIM compiler plugin for OpenFOAM Copy blockMesh.vim to foam.vim.\nDon\u0026rsquo;t forget let current_compiler = \u0026quot;foam\u0026quot; Declare a script variable, storing the solver name let s:foamApp = FOAMGetApplication() Instead of CompilerSet, define a new function setting the compiler to the solver name, then call it. function! FOAMSetCompiler() exe \u0026#39;CompilerSet makeprg=\u0026#39;.s:foamApp endfunction call FOAMSetCompiler() For the file line in the error format, use \\\\file:\\ %f\\.%*[a-zA-Z]%*[a-zA-Z\\ .]\\ line\\ %l%*[.a-zA-Z0-9\\ ] So we can cover stuff like \u0026ldquo;from line 15 to line 20.\u0026rdquo; and be more dynamic with the number of dots in the filename (handle things like 0/U.boundaryField.inlet). Done!! We are ready to go! Final tweaks: VIM\u0026rsquo;s auto-commands We only need to tell VIM to set the compiler to \u0026ldquo;foam\u0026rdquo; whenever a Foam File is opened; and to set the compiler to blockMesh if the entered buffer is named blockMeshDict.\naugroup FOAMautocmds autocmd! autocmd FileType foam* call FOAMSetPathToCaseDir() autocmd FileType foam* compile foam autocmd BufEnter *blockMeshDict compile blockMesh augroup End {{ notice \u0026ldquo;tip\u0026rdquo; }} *FileType* autocmds will always be executed before BufEnter ones, so blockMeshDict files will always have blockMesh as their compiler. {{ /notice }}\nThe complete configuration files can be downloaded from here: Vim Customization "},{"section":"Blog","slug":"/blog/vim-openfoam-power-part1/","title":"Customize VIM to work efficiently with OpenFOAM - Part 1","description":"Working with OpenFOAM case files gets really tedious if the text editor is not selected properly; and with VIM I still feel like missing some features, that&#39;s why customizing VIM for such tasks is the best path to take","date":"August 27, 2018","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/vim-openfoam_hu2ee0a4cb629d438b90e279549678bc92_82586_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"250\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/vim-openfoam_hu2ee0a4cb629d438b90e279549678bc92_82586_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/vim-openfoam_hu2ee0a4cb629d438b90e279549678bc92_82586_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/vim-openfoam_hu2ee0a4cb629d438b90e279549678bc92_82586_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"productivity","tags":"OpenFOAM, Vim","content":"Today, I\u0026rsquo;m starting a new (short) post series suggesting tricks to customize the VIM text editor so that it can be used to edit OpenFOAM cases more efficiently. Of course, making VIM work optimally with every single piece of software you have installed through scripting is a bit of an \u0026ldquo;overkill,\u0026rdquo; but having it configured properly is crucial.\nNote\nThese series of posts are for those who are ready to write some lines of VIML code to add interesting functionality to VIM (OpenFOAM-wise).\nWarning\nThis post is outdated; there are better ways to efficiently edit OpenFOAM files with (Neo)Vim:\ntree-sitter-foam : OpenFOAM syntax highlighting using tree-sitter for NeoVim. foam-language-server : A language server for OpenFOAM files. VIM Plugins for OpenFOAM We can easily customize our VIM installation using our own scripts, sourced in the .vimrc file. The versatility of VIM allows for sharing these scripts between users; we then call the scripts: Plug-ins.\nThese plugins differ in both their goal and their implementation:\nGeneral purpose plugins, e.g., for handling text formatting, VIM configuration. File-Type specific plugins, e.g., those which operate only on C source/header files. Syntax highlighting, e.g., highlight OpenFOAM keywords in an OpenFOAM dictionary. Compiler plugins, e.g., interpret a Python script from VIM command line and jump to errors. As OpenFOAM users, we\u0026rsquo;ll naturally be interested in any C++ related plugins in addition to a few OpenFOAM-specific ones.\nSyntax Highlighting of OPENFOAM dictionaries in VIM It\u0026rsquo;s always good to have keyword-specific highlighting of a file; It helps you instantly catch misspelled keywords, it makes understanding the file easier; and with appropriate color themes, it makes you feel comfortable while editing the file.\nThere is already a VIM plugin that takes care of OpenFOAM keywords highlighting (Vim-OpenFOAM-syntax). It\u0026rsquo;s true that the plugin does some weird stuff (eg. loading weird files into the buffer list) but, in general, it\u0026rsquo;s good for the job of highlighting OpenFOAM syntax. To install it on your system, follow the instructions at Vim-OpenFoam-syntax on github, or the fork for manual installation (not that scary) Vim-Extension-OpenFOAM on bitbucket.\nWhile programming, I usually use a couple of VIM plugins:\nc-support: to turn VIM into a C/C++ IDE (code snippets \u0026hellip; etc). taglist: to browse source code efficiently Your own VIM scripts In this blog post, we\u0026rsquo;ll write a very small VIM script called customFoam.vim, which is capable of doing a couple of things:\nIt needs to be aware of the current file\u0026rsquo;s FileType. When the file is of type foam, VIM should set a couple of things up: Changing the path variable for the :find command so it includes our case\u0026rsquo;s directory. Changing VIM\u0026rsquo;s current directory to the case directory. At this moment, that\u0026rsquo;s all, but we\u0026rsquo;ll add some stuff in the upcoming blog posts. First steps: Determining file types There are two common ways to determine a file type for a file:\nUse the extension in its same; I call it the lazy Windows way: for example ,files that have names ending with .html are considered HTML files no matter what their content is. Take a look at the file\u0026rsquo;s content then decide; This is the Unix way, which we\u0026rsquo;ll be using here: It just means we\u0026rsquo;ll search the content of a file for the line that says FoamFile. We are not the first ones who try to detect foam file type in VIM; the vim-OpenFoam-syntax plugin already does that. Actually, it assigns different file types for different foam files. For example, it sets: ft=\u0026quot;foam256_thermodynamicProperties\u0026quot; for thermodynamicProperties dictionaries, but in general, its sets the file type to foam256_general.\nThus, if you have the plugin installed, you already have the required means to detect foam file type. However, for the sake of leaning VIM, we\u0026rsquo;ll illustrate a very quick way to do it (but not that efficient!).\nAll what we have to do is to write a small script -which contains only one function- searching the first few lines of a file for the keyword FoamFile. This tells VIM that the file is a OpenFOAM Dictionary File:\n\u0026#34; Filename: foamFT.vim \u0026#34; No debug stuff \u0026#34; Should check if the file type is already set \u0026#34; But it\u0026#39;s OK; just set it again function! SetFoamType() \u0026#34; loop through the first 10 lines \u0026#34; FoamFile is at line 8 usually for nL in range(1,10) \u0026#34; match \u0026#39;FoamFile\u0026#39; if (getline(nL) =~ \u0026#39;FoamFile\u0026#39;) setfiletype foam \u0026#34; if file type is set, leave the loop break endif endfor endfunction \u0026#34; That\u0026#39;s it! \u0026#34; Now, when to call it? augroup FOAMFTautocmds autocmd! autocmd BufRead * call SetFoamType() augroup End To check whether the script works or not; Just execute the ex-command :set ft while an OpenFOAM dictionary is loaded. If it works, the output should say filetype=foam.\nNow we know the filetype, then what? Well, VIM knows what we are editing, but it doesn\u0026rsquo;t know where we are editing it. In fact, it does know the exact path to the current file (try running the ex-command :pwd): VIM considers the startup directory as your current directory, and to change it, guess what, we have to use the :cd (change directory!) command.\nIf you invoke VIM from the case directory, you\u0026rsquo;ll have the advantage of file names auto-completion in command-line mode; that is, when you type :e c\u0026lt;TAB\u0026gt;, VIM automatically completes constant for you. But, if, for example, you invoke it from the system directory of a case, it won\u0026rsquo;t know about the files in the other directories (0, constant, etc.).\nThere\u0026rsquo;s also the super-useful command :find which finds the specified file in the path (could include multiple independent directories) and then edits it. The desired workflow can be summarized as follows: While editing blockMeshDict in the system directory of a case, type :find t\u0026lt;TAB\u0026gt;, which instantly expands to :find transportProperties (Note that this file is located under the constant directory), then, hitting ENTER switches to that file to edit it.\n\u0026#34; Filename: customFoam.vim function! FOAMSetPathToCaseDir() \u0026#34; IF you care only for files in \u0026#34; system, 0, and constant, use \u0026#34; let caseDir = expand(\u0026#39;%:p:h:h\u0026#39;) \u0026#34; But, I\u0026#39;m a regexp lover, so, \u0026#34; Make Vim remember everything in the path until case name. \u0026#34; delete everything else! let caseDir = expand(\u0026#39;%:p:s?\\(\\/.*run\\/[a-zA-Z1-9\\. ]*\\)\\/.*?\\1?\u0026#39;) \u0026#34; set path to include all subdirs of caseDir. \u0026#34; you can also use \u0026#39;=+\u0026#39; instead of \u0026#39;=\u0026#39; to add the caseDir to \u0026#34; the default path; but I like it this way. exe \u0026#39;set path=\u0026#39;.caseDir.\u0026#39;/**\u0026#39; \u0026#34; I want to run blockMesh, solvers and other tools \u0026#34; Directly in VIM, so change dir to casedir exe \u0026#39;cd \u0026#39;.caseDir endfunction \u0026#34; This is just incredible augroup FOAMautocmds autocmd! autocmd FileType foam* call FOAMSetPathToCaseDir() augroup End Let\u0026rsquo;s go through that script line-by-line, shall we?\nfunction! FOAMSetPathToCaseDir() overwrites any function defined with this name (Remember, user-defined function names start with a capital letter). endfunction denotes the end of function block.\nAll lines preceded with ( \u0026quot; ) are considered comments.\nThe line let caseDir = expand('%:p:s?\\(\\/.*run\\/[a-zA-Z1-9\\. ]*\\)\\/.*?\\1?') needs deeper explanation:\nThe standard function let defines Vim Variables (In this case, variables are local to the user-defined function). caseDir is the name of our variable (a string). It is local to the function: To use a global variable inside a function, name it g:var, to make it available only in this script, use s:var, and, in fact, to use a local variable in a function, it should be called l:var, but this is tolerated. The standard function expand manipulates filenames (shortcut %) and paths to them, with modifiers: :p prints the whole absolute path to the file, eg. while editing blockMeshDict, the ex-command echo expand('%:p') should display something like /home/path-to-case/system/blockMeshDict. :h removes the last entry in a path, eg. echo expand('%:p:h') would display /home/path-to-case/system :s?pattern?string? acts like the substitute command. pattern is a regular expression, and string accepts back-references; All the power one needs in one command. So, the regexp \\(\\/.*run\\/[a-zA-Z1-9\\. ]*\\)\\/.* remembers everything from the start of filename to \u0026ldquo;run\u0026rdquo; (hopefully, your OpenFOAM cases directory) to the first directory (that\u0026rsquo;s the case dir. at least for me). Case Name may contain alphabet characters, digits, dots and spaces (The last two are really bad options). The rest of the path is forgotten (eg. /system/blockMeshDict). This way, we can find our path to the case no matter what case file we are editing!\nIn the line exe 'set path='.caseDir.'/**' , the command exe (short for execute) executes the following string as an ex-command. Concatenation in VIML is done with a dot, and because our caseDir variable is a string, and we are still inside the same function, it can be concatenated with other strings. The /** part expands to all sub-directories, to the last one of them, no matter how many levels of directories the case have.\nThe path variable is set so the :find command can help us a bit.\nI like to change the directory to the case dir. so I can run commands directly from within VIM without worrying about which files I\u0026rsquo;m editing, or the start-up directory. For that, we simply use the :cd ex-command (VIM\u0026rsquo;s command).\nThe function is completed, now, we have to find a way to automate calling it: auto-commands. Simply, we group all of our autocmds in a group called FOAMautocmds (Good practice but optional) .\nautocmd! overwrites previous autocmds of this group (often abbreviated as au!).\nWe want to call the function when we open a file of type foam* (including foam, foam_general, etc.), so we write: autocmd FileType foam* call FOAMSetPathToCaseDir() That\u0026rsquo;s it, source the script in your .vimrc file, and you are good to test it out:\nFrom the shell (from /../constant/polyMesh in an arbitrary OpenFOAM case, where the mesh is present) run vim boundary.\nNow, in Vim, type :fin tr\u0026lt;TAB\u0026gt; (fin is a short form for find), then hit ENTER.\nCheck both the path and the working directory (using :set path and :pwd respectively).\nYou can issue :!blockMesh while editing the file to rebuild the mesh.\nThat\u0026rsquo;s it for now; the next post will explain ways to get the most out of VIM compilers to run blockMesh and OpenFOAM solvers on cases right from inside VIM and browse errors.\n"},{"section":"Blog","slug":"/blog/permeability-simulation-with-openfoam-and-openpnm/","title":"Permeability Simulation with OPENFOAM and OPENPNM","description":"Compare Network-based models to CFD simulations in porous mediums","date":"January 2, 2018","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/openfoam-pressure-permeability-results_hu8926a4d0f16743ed164258e025fc6888_122180_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"232\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/openfoam-pressure-permeability-results_hu8926a4d0f16743ed164258e025fc6888_122180_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/openfoam-pressure-permeability-results_hu8926a4d0f16743ed164258e025fc6888_122180_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/openfoam-pressure-permeability-results_hu8926a4d0f16743ed164258e025fc6888_122180_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"porous-medium","tags":"OpenFOAM, Pore-network, Permeability, OpenPNM, PoreSpy, Python","content":"Permeability and Filtration coefficients are some must-know factors for oil/gas reservoir management and optimization. OpenFOAM and Network-based software (OpenPNM for example) are our chosen open-source software toolkits for permeability simulation.\nIt\u0026rsquo;s hard to define an audience for this presentation, really. Anyone who wants to:\nKill the time by learning about permeability of soils, or Prepare for a numerical simulation of permeability of soils And understands the basics of:\nFlow through porous medium, OpenFOAM, or Python programming language, Image processing (we are using FIJI \u0026ndash; Fiji Is Just ImageJ \u0026ndash; ) Should be able to benefit from this presentation and related files (The way I presented it: Split it up to parts and give each part to the appropriate audience). Abstract One of the most important properties of hydrocarbon reservoirs is their capacity of passing fluids; ie, their permeability to fluids in question. The engineering knowledge have accumulated over the years to explain, optimize and use the behavior of reservoirs in this matter.\nWith a great focus on granular reservoirs, this presentation introduces key concepts regarding this interesting property of rocks, including the most effective way of comparing two reservoirs in respect to their permeability: The use of permeability coefficient; In addition, we\u0026rsquo;ve tried to present the most important factors affecting rock permeability, and how they affect it.\nBased on these factors, several mathematical models -adhering to certain conditions- were formed; we\u0026rsquo;ve picked two well-known well-accepted models to feature: Kozeny-Carman (relatively simple porosity-permeability relationship); Happel-Brenner (more complex porosity-permeability relationship).\nWith their “very limited” porosity range, these models fail in predicting the permeability of many rock sample; especially if they require the determination of grain shape descriptors (sphericity, roundness … etc).\nThus, results from mathematical predictions are always treated with caution; The most accurate method to estimate permeability of a sample rock to a certain test fluid is to actually measure it (More precisely, calculate it from measured data). This paper features the most-common permeability tests methods (Principle: apply pressure gradients, measure the outgoing flow rate, and use Darcy\u0026rsquo;s law to determine permeability). We\u0026rsquo;ve also tried to show how field-based methods (Well tests and logs) are used to estimate permeability.\nTo formulate a better understanding of this concept, we\u0026rsquo;ve tried to use common simulation approaches to determine the permeability of a piece of porous material (a 2-D 1.024mm×0.728mm image generated with PoreSpy - a Python Library -):\nDirectly simulate a viscous flow through medium\u0026rsquo;s pores using OpenFOAM (The most trusted method). Instead of real pore (complex) geometry, assemble the porous material to a network of spheres (pores) connected by cylinders (throats), and solve the flow there, using PpenPNM - also a Python Library -. Downloads Note\nPDF files are meant to be opened with evince (don\u0026rsquo;t complain about animations if you use Adobe Reader); OpenFOAM cases are packaged in a ready-to-mesh-and-run state, and python scripts are meant to show the typical workflow - not to provide fully-featured applications.\nPresentation File OpenFOAM case (.7z) Python Stuff Latex Sources The presentation file can be downloaded from SlideShare:\nDownload\nThe following Google Drive link gets you access to the corresponding OpenFOAM case:\nDownload\nYou can also get the OpenPNM/PoresSpy scripts too:\nDownload\nIf you\u0026rsquo;re interested, Beamer Latex sources are also available:\nDownload\n"}]